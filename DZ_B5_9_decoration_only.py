import time
# Опциональные задания в двух других файлах:
# задание с одной звездочкой: написать декоратор в качестве объекта класса-секундомера;
# задание с двумя звездочками: написать декоратор в качестве объекта класса-секундомера, который можно использовать как контекстный менеджер.
# Кстати, вот наблюдение. В юните B5.7 была задачка на последовательность Фибоначчи. Если увеличить верхнюю границу последовательности, то функцию, написанную в той задачке, можно прогнать для отладки поведения секундомера.
def time_this(num_runs): # здесь передается число запусков  как параметр.
    def decorator(func): # в данном случае внутри вложенной функции (где-то в декораторе) выводитcя
                            # среднее время выполнения;
        def wrap():
            avg_time = 0
            for _ in range(num_runs):
                t0 = time.time()
                ### <<полезный>> код, скорость которого мы оцениваем
                func()
                t1 = time.time()
                avg_time += (t1 - t0)
            avg_time /= num_runs
            return print("Среднее время по ", str(num_runs), "итерациям заняло %.5f секунд" % avg_time)
        return wrap
    return decorator


@time_this(num_runs=100) # 100 итераций как параметр - время ожидания результата - несколько секунд (приблизительно 5)
def f():
    for j in range(1000000):
        pass

f()